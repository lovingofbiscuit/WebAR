<!doctype html>
<html>
<head>
  <meta http-equiv="cache-control" content="no-cache, no-store, must-revalidate" />
  <meta http-equiv="pragma" content="no-cache" />
  <meta http-equiv="expires" content="0" />
  <meta charset="UTF-8">
  <meta name="viewport"
        content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
  <title>TestAR rlinosaur</title>
  <script src="./libs/three.js"></script>
  <script src="./libs/GLTFLoader.js"></script> 
  <style>
    body { margin: 0; }
    canvas { display: block; }
    #startButton { position: absolute; top: 20px; left: 20px; padding: 10px 20px; font-size: 16px; }
    #errorMessage { position: absolute; top: 60px; left: 20px; color: red; font-size: 16px; }
  </style>
</head>
<body>
    <!-- <button style="margin:15px;" onclick="activateXR()">Нажми меня (иначе ничего не заработает)</button> -->
    <button id="startButton">Нажми меня</button>
    <p id="errorMessage"></p>
    <canvas id="renderCanvas"></canvas>
<script>    
    //https://github.com/immersive-web/webxr-samples/blob/main/ar-barebones.html
    var parrot = undefined    
    var globax = undefined
    let referenceSpace
    let hitTestSource, hitTestSourceInitialized = false;
    let canvas, renderer
    let gl,scene,loader,aLight,pLight,camera
    let xrSession
    let yrot = -0.05, xrot=0.00
    function debug(message){
      let em = document.getElementById('errorMessage')
      em.textContent = `${em.textContent}-.${message}.-`
    }
    function initScene()
    {
        debug(`Инициализация сцены`)        
        //gl = canvas.getContext("webgl", {xrCompatible: true});        
        scene = new THREE.Scene();
        loader = new THREE.GLTFLoader();
        aLight = new THREE.AmbientLight(0x404040,1.2);
        scene.add(aLight);
        pLight = new THREE.PointLight(0xFFFFFF, 1.2);
        pLight.position.set(0,-3,7);
        scene.add(pLight);        
        renderer = new THREE.WebGLRenderer({
          alpha: true,
          preserveDrawingBuffer: true,
          canvas: canvas,
          context: gl
        });
        renderer.autoClear = false;        
        camera = new THREE.PerspectiveCamera();
        camera.matrixAutoUpdate = false;        
        let cameraPosition = new THREE.Vector3();
        camera.getWorldPosition(cameraPosition);        
        let cameraDirection = new THREE.Vector3();
        camera.getWorldDirection(cameraDirection);        
        let offset = cameraDirection.multiplyScalar(1.5);        
        let cubePosition = cameraPosition.add(offset);
        loader.load("/img/3d/parrot.glb", function(gltf) {
          const model = gltf.scene;    
          const instance = model.clone()   
          instance.position.set(cubePosition.x,cubePosition.y,cubePosition.z)
          instance.scale.set(0.01,0.01,0.01)
          parrot = instance    
          scene.add(instance)  
        });  
        loader.load("/img/3d/globax.glb", function(gltf) {
          const model = gltf.scene;    
          const instance = model.clone()   
          instance.position.set(cubePosition.x,cubePosition.y,cubePosition.z)
          instance.scale.set(0.5,0.5,0.5)
          globax = instance    
          scene.add(instance)  
        });
    }
    debug(`Инициализация страницы`)    
    document.getElementById('startButton').addEventListener('click', () => {
      //canvas = document.createElement("canvas");
      //document.body.appendChild(canvas);
      navigator.xr.requestSession('immersive-ar', { requiredFeatures: ['hit-test'], optionalFeatures: ['plane-detection'] })
        .then(session => {
            xrSession = session;
            xrSession.addEventListener('end', onSessionEnded);
            xrSession.requestReferenceSpace('local').then(refSpace => {
                referenceSpace = refSpace;
                xrSession.requestAnimationFrame(onXRFrame);
            });
            canvas = document.getElementById('renderCanvas');
            gl = canvas.getContext('webgl', { xrCompatible: true });
            xrSession.updateRenderState({ baseLayer: new XRWebGLLayer(xrSession, gl) });
            initScene();
        })
        .catch(err => {
            debug(`Error starting AR session: ${err.message}`)            
        });

    })
    function onSessionEnded() {
        hitTestSource = null;
        xrSession = null;
    }
    const onXRFrame = (time, frame) => {  
      xrSession.requestAnimationFrame(onXRFrame);  
          gl.bindFramebuffer(gl.FRAMEBUFFER, xrSession.renderState.baseLayer.framebuffer)          
          const pose = frame.getViewerPose(referenceSpace);
          if (pose) {    
              const view = pose.views[0];
              const viewport = xrSession.renderState.baseLayer.getViewport(view);
              renderer.setSize(viewport.width, viewport.height)    
              camera.matrix.fromArray(view.transform.matrix)
              camera.projectionMatrix.fromArray(view.projectionMatrix);
              camera.updateMatrixWorld(true);           
              parrot.rotation.y +=yrot;
              parrot.rotation.x +=xrot;
              if (!hitTestSourceInitialized) {
                    xrSession.requestHitTestSource({ space: referenceSpace }).then(source => {
                    hitTestSource = source;
                    hitTestSourceInitialized = true;
                    debug('Инициализация источника Hit-test проведена успешно.')
                  }).catch(err => {
                    debug(`Error initializing hit test source: ${err.message}`)                     
                  });
              }
              if (hitTestSourceInitialized)
              {
                  //debug('Ищем хит')
                  const hitTestResults = frame.getHitTestResults(hitTestSource);
                  if (hitTestResults.length > 0) {
                      debug('Найдено столкновений'+hitTestResults.length)
                      const hit = hitTestResults[0];
                      const hitPose = hit.getPose(referenceSpace);
                      //globax.position.set(hitPose.transform.position.x, hitPose.transform.position.y, hitPose.transform.position.z);
                      globax.position.set(hitPose.transform.position.x, hitPose.transform.position.y, hitPose.transform.position.z);
                      //globax.rotation.y += yrot;
                      //globax.rotation.x += xrot;
                  }
              }              
              renderer.render(scene, camera)
          }
        }
</script>
</body>
</html>
